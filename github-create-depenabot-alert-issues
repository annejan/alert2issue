#!/usr/bin/env python3

import argparse
import subprocess
import json
import shlex
from pathlib import Path

def run_gh_command(cmd, capture_json=True):
    try:
        full_cmd = shlex.split(cmd)
        result = subprocess.run(
            full_cmd,
            capture_output=True,
            check=True,
            text=True
        )
        return json.loads(result.stdout) if capture_json else result.stdout.strip()
    except subprocess.CalledProcessError as e:
        print(f"‚ùå Command failed: {cmd}")
        print(e.stderr)
        return None

def ensure_label(repo, label, color, description, dry_run=False):
    existing_labels = run_gh_command(f"gh label list --repo {repo} --limit 100", capture_json=False)
    if not existing_labels or not any(line.startswith(label) for line in existing_labels.splitlines()):
        action = "Would create" if dry_run else "Creating"
        print(f"üõ†Ô∏è {action} label: {label} in {repo}")
        if dry_run:
            return
        try:
            subprocess.run([
                "gh", "label", "create", label,
                "--repo", repo,
                "--color", color,
                "--description", description
            ], check=True)
        except subprocess.CalledProcessError:
            print(f"‚ö†Ô∏è  Failed to create label: {label} in {repo}")

def create_issue(repo, title, body, dry_run=False):
    if dry_run:
        print(f"üìù Would create issue in {repo}:\n  Title: {title}\n  Body (truncated): {body[:100]}...")
        return
    try:
        subprocess.run([
            "gh", "issue", "create",
            "--repo", repo,
            "--title", title,
            "--body", body,
            "--label", "security",
            "--label", "dependabot"
        ], check=True)
        print(f"üìù Created issue in {repo}: {title}")
    except subprocess.CalledProcessError:
        print(f"‚ùå Failed to create issue in {repo}: {title}")

def process_repo(repo, dry_run=False):
    print(f"üîç Checking alerts for: {repo}")
    alerts_json = run_gh_command(
        f'gh api -X GET "/repos/{repo}/dependabot/alerts?per_page=100" --paginate',
        capture_json=True
    )
    if not alerts_json:
        print(f"‚úÖ No open dependabot alerts found for {repo}.")
        return

    for alert in alerts_json:
        if alert["state"] != "open":
            continue

        pkg = alert["security_vulnerability"]["package"]["name"]
        eco = alert["security_vulnerability"]["package"]["ecosystem"]
        sev = alert["security_advisory"]["severity"]
        desc = alert["security_advisory"]["description"]
        range_ = alert["security_vulnerability"]["vulnerable_version_range"]
        patched = (alert["security_vulnerability"].get("first_patched_version") or {}).get("identifier", "Not specified")
        cves = ", ".join([i["value"] for i in alert["security_advisory"]["identifiers"] if i["type"] == "CVE"]) or "None"
        url = alert["html_url"]
        created = alert["created_at"]

        issue_title = f"[Dependabot] Security Alert for: {pkg} ({eco})"
        issue_body = f"""**Package:** {pkg} ({eco})

**Severity:** {sev}
**Created At:** {created}
**CVE(s):** {cves}
**Affected Versions:** {range_}
**First Patched Version:** {patched}

**DESCRIPTION:**
{desc}

[View Alert]({url})
"""

        # Check for existing issue
        existing_title = run_gh_command(
            f'gh issue list --repo {repo} --search "{issue_title} in:title" --state open --json title --jq ".[0].title"',
            capture_json=False
        )

        if existing_title == issue_title:
            print(f"‚ö†Ô∏è  Issue already exists in {repo}: '{issue_title}'. Skipping...")
            continue

        ensure_label(repo, "security", "d73a4a", "Security-related issues", dry_run)
        ensure_label(repo, "dependabot", "0366d6", "Dependabot alerts", dry_run)

        create_issue(repo, issue_title, issue_body, dry_run)

def load_repos_from_file(path):
    repos = []
    with open(path) as f:
        for line in f:
            clean = line.split('#')[0].strip()
            if clean:
                repos.append(clean)
    return repos

def main():
    parser = argparse.ArgumentParser(description="Check GitHub repos for Dependabot alerts and file issues.")
    parser.add_argument("repo_file", help="File containing list of GitHub repositories")
    parser.add_argument("--dry-run", action="store_true", help="Print actions but don't make any changes")
    args = parser.parse_args()

    path = Path(args.repo_file)
    if not path.exists():
        print(f"‚ùå File not found: {args.repo_file}")
        return

    repos = load_repos_from_file(path)
    for repo in repos:
        process_repo(repo, dry_run=args.dry_run)

if __name__ == "__main__":
    main()

